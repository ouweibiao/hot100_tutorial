# 11. 盛最多水的容器 - 编程指导

## 🎯 学习目标
- 掌握双指针（对撞指针）的应用
- 理解贪心策略的证明
- 学会分析时间复杂度的优化

---

## 📖 题目回顾

给定数组 `height`，找两条线使得与 x 轴形成的容器能容纳最多的水。

**示例**：
```
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```

---

## 💭 思考提示（分4级）

### 🌟 提示 Level 1：理解问题
<details>
<summary>点击查看提示1</summary>

**问题1**：容器的面积如何计算？

**答案**：
```
面积 = 宽度 × 高度
宽度 = 两条线的水平距离
高度 = 两条线中较短的那条（木桶短板）
```

**示例**：
```
height = [1, 8, 6]
选择 i=1, j=2:
  宽度 = 2 - 1 = 1
  高度 = min(8, 6) = 6
  面积 = 1 × 6 = 6
```

**问题2**：最简单的方法？

枚举所有可能的两条线组合。

</details>

---

### 🌟 提示 Level 2：发现规律
<details>
<summary>点击查看提示2</summary>

**思考**：从两端开始，如何决定移动哪个指针？

**初始状态**：
```
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
          ↑                       ↑
        left                    right
```

**情况分析**：
- `height[left] = 1`（较矮）
- `height[right] = 7`（较高）
- 当前面积 = `8 × min(1, 7) = 8`

**如果移动 right**：
- 宽度减小：`8 → 7`
- 高度最多 = 1（因为左边是1）
- 面积最多 = `7 × 1 = 7` < 8

**如果移动 left**：
- 宽度减小：`8 → 7`
- 高度可能增加（可能 > 1）
- 面积有可能增加

**结论**：应该移动较矮的一边！

</details>

---

### 🌟 提示 Level 3：算法框架
<details>
<summary>点击查看提示3</summary>

```cpp
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxWater = 0;
    
    while (left < right) {
        // 计算当前面积
        int width = right - left;
        int h = min(height[left], height[right]);
        int area = width * h;
        maxWater = max(maxWater, area);
        
        // 移动较矮的一边
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxWater;
}
```

**关键点**：
1. 两个指针从两端开始
2. 每次计算当前面积
3. 移动较矮的指针
4. 更新最大值

</details>

---

### 🌟 提示 Level 4：证明正确性
<details>
<summary>点击查看提示4</summary>

**问题**：为什么移动较矮的指针不会错过最优解？

**证明**（反证法）：

假设最优解是 `(i, j)`，且 `height[i] ≤ height[j]`。

**情况1**：当指针在 `(i, k)` 且 `k > j` 时
- 我们会移动指针直到到达 j
- 在移动过程中，任何 `(i, k')` 其中 `k' > j` 的面积都 ≤ `(i, j)`
- 因为宽度更大但高度受限于 `height[i]`

**情况2**：当指针在 `(k, j)` 且 `k < i` 时
- 如果 `height[k] < height[i]`，面积必然 < `(i, j)`
- 如果 `height[k] ≥ height[i]`，我们会移动右指针（因为 `height[k] ≤ height[j]`）

**结论**：算法保证不会错过最优解。

</details>

---

## 🔨 动手实践

### 任务1：手动模拟
对 `height = [4, 3, 2, 1, 4]`，填写：

| Step | left | right | height[left] | height[right] | area | maxWater | 移动 |
|------|------|-------|--------------|---------------|------|----------|------|
| 0    | 0    | 4     | ?            | ?             | ?    | ?        | ?    |
| 1    | ?    | ?     | ?            | ?             | ?    | ?        | ?    |
| 2    | ?    | ?     | ?            | ?             | ?    | ?        | ?    |

### 任务2：实现代码
```cpp
int maxArea(vector<int>& height) {
    // TODO: 实现双指针算法
}
```

### 任务3：测试用例
```cpp
// 用例1
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]  // 预期: 49

// 用例2：递增
height = [1, 2, 3, 4, 5]  // 预期: 6 (1和5)

// 用例3：递减
height = [5, 4, 3, 2, 1]  // 预期: 6 (5和1)

// 用例4：相等
height = [2, 2, 2, 2]  // 预期: 6 (任意两边)
```

---

## 🎯 核心技巧

### 1. 双指针类型对比

| 类型 | 移动方式 | 适用场景 |
|------|----------|----------|
| 快慢指针 | 同向移动 | 原地修改、链表环 |
| 对撞指针 | 相向移动 | 两端查找、有序数组 |

### 2. 移动决策

**通用原则**：
- 移动"劣势"的一边
- 本题：移动较矮的边
- 三数之和：移动使和接近目标的边

---

## 🚀 进阶挑战

### 挑战1：返回两条线的索引
不仅返回最大面积，还要返回是哪两条线。

### 挑战2：接雨水（LeetCode 42）
计算所有柱子之间能接多少雨水。

**提示**：
- 盛水容器：只考虑两端
- 接雨水：考虑中间所有柱子

### 挑战3：三维版本
如果是三维空间的容器问题，如何求解？

---

## ✅ 自检清单

- [ ] 我理解了面积的计算公式
- [ ] 我知道为什么移动较矮的一边
- [ ] 我能用反证法证明算法正确性
- [ ] 我理解了对撞指针的原理
- [ ] 我能独立实现代码
- [ ] 我测试了边界情况

---

## 📌 口诀

> 两端出发向中间，对撞指针解难题。  
> 短板决定水高度，移动短边找最优。  
> 宽度减小高可增，贪心策略不错过。

---

**下一步**：独立实现并对照 `solution.md`！
