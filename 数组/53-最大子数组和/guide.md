# 53. 最大子数组和 - 编程指导

## 🎯 学习目标
通过这道题，你将掌握：
- 动态规划的经典应用
- 从暴力到最优的思维优化过程
- Kadane 算法（卡登算法）

---

## 📖 题目回顾

找出数组中和最大的连续子数组。

**示例**：
```
输入：nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
输出：6
解释：[4, -1, 2, 1] 的和最大
```

---

## 💭 思考提示（分4级，逐步深入）

### 🌟 提示 Level 1：理解问题
<details>
<summary>点击查看提示1</summary>

**问题1**：什么是连续子数组？

**示例**：`nums = [1, 2, 3, 4]`
- ✅ 连续：`[1,2]`, `[2,3,4]`, `[1,2,3,4]`
- ❌ 不连续：`[1,3]`, `[1,4]`

**问题2**：最简单的方法是什么？

**思考**：
- 可以枚举所有可能的连续子数组
- 对每个子数组计算和，取最大值

**伪代码**：
```
for 起点 i:
    for 终点 j (从 i 开始):
        计算 nums[i..j] 的和
        更新最大值
```

**复杂度**：O(n²)，当 n=10^5 时太慢！

</details>

---

### 🌟 提示 Level 2：观察规律
<details>
<summary>点击查看提示2</summary>

**核心问题**：对于每个位置 `i`，如何确定以它结尾的最大子数组和？

**思考过程**（以示例为例）：

```
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

**当我们到达位置 i 时，有两个选择：**

1. **接上前面的子数组**：如果前面的和是正数，有帮助
2. **重新开始**：如果前面的和是负数，拖后腿

**示例分析**：
```
i=0: nums[0]=-2, 最大和=-2
i=1: nums[1]=1
     - 选择1: -2+1=-1
     - 选择2: 1
     - 取较大: 1 (重新开始更好)

i=2: nums[2]=-3
     - 选择1: 1+(-3)=-2
     - 选择2: -3
     - 取较大: -2 (接上前面)

i=3: nums[3]=4
     - 选择1: -2+4=2
     - 选择2: 4
     - 取较大: 4 (重新开始)
```

**发现规律**：
```
以 nums[i] 结尾的最大和 = max(前面的最大和 + nums[i], nums[i])
```

</details>

---

### 🌟 提示 Level 3：动态规划
<details>
<summary>点击查看提示3</summary>

**定义状态**：
- `dp[i]`：以 `nums[i]` 结尾的最大子数组和

**状态转移方程**：
```cpp
dp[i] = max(dp[i-1] + nums[i], nums[i])
```

**直观理解**：
- 如果 `dp[i-1] > 0`：前面有贡献 → 接上
- 如果 `dp[i-1] <= 0`：前面是负担 → 抛弃，重新开始

**代码框架**：
```cpp
int maxSubArray(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n);
    
    dp[0] = nums[0];  // 初始化
    int maxSum = dp[0];
    
    for (int i = 1; i < n; i++) {
        dp[i] = max(dp[i-1] + nums[i], nums[i]);
        maxSum = max(maxSum, dp[i]);  // 记录全局最大值
    }
    
    return maxSum;
}
```

**复杂度**：
- 时间：O(n)
- 空间：O(n)

**思考**：能否优化空间？

</details>

---

### 🌟 提示 Level 4：空间优化
<details>
<summary>点击查看提示4</summary>

**观察**：`dp[i]` 只依赖于 `dp[i-1]`，不需要整个数组。

**优化**：用一个变量代替 DP 数组。

```cpp
int maxSubArray(vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];  // 相当于 dp[i-1]
    
    for (int i = 1; i < nums.size(); i++) {
        // 状态转移
        currentSum = max(currentSum + nums[i], nums[i]);
        
        // 更新全局最大值
        maxSum = max(maxSum, currentSum);
    }
    
    return maxSum;
}
```

**复杂度**：
- 时间：O(n)
- 空间：O(1) ✅

**这就是著名的 Kadane's Algorithm（卡登算法）！**

</details>

---

## 🔨 动手实践

### 任务1：手动模拟
对数组 `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`，填写下表：

| i | nums[i] | currentSum | maxSum |
|---|---------|------------|--------|
| 0 | -2      | ?          | ?      |
| 1 | 1       | ?          | ?      |
| 2 | -3      | ?          | ?      |
| 3 | 4       | ?          | ?      |
| 4 | -1      | ?          | ?      |
| 5 | 2       | ?          | ?      |
| 6 | 1       | ?          | ?      |
| 7 | -5      | ?          | ?      |
| 8 | 4       | ?          | ?      |

### 任务2：实现代码
按照提示4的框架，独立实现代码。

### 任务3：测试用例
```cpp
// 用例1：全正数
nums = [1, 2, 3, 4]  // 预期: 10

// 用例2：全负数
nums = [-3, -2, -5, -1]  // 预期: -1

// 用例3：混合
nums = [5, -3, 5]  // 预期: 7

// 用例4：单个元素
nums = [1]  // 预期: 1
```

---

## 🎯 算法比较

### 方法1：暴力枚举
```cpp
for (int i = 0; i < n; i++) {
    int sum = 0;
    for (int j = i; j < n; j++) {
        sum += nums[j];
        maxSum = max(maxSum, sum);
    }
}
```
- 时间：O(n²)
- 空间：O(1)

### 方法2：动态规划（DP数组）
```cpp
dp[i] = max(dp[i-1] + nums[i], nums[i]);
```
- 时间：O(n)
- 空间：O(n)

### 方法3：Kadane算法（滚动变量）
```cpp
currentSum = max(currentSum + nums[i], nums[i]);
```
- 时间：O(n) ✅
- 空间：O(1) ✅

---

## 🧠 贪心角度理解

也可以用贪心思想：
```cpp
int currentSum = 0;
int maxSum = INT_MIN;

for (int num : nums) {
    if (currentSum < 0) {
        currentSum = num;  // 前面是负担，重新开始
    } else {
        currentSum += num;  // 继续累加
    }
    maxSum = max(maxSum, currentSum);
}
```

**贪心策略**：
- 维护当前子数组和
- 如果变成负数，立即抛弃，从下一个元素重新开始

---

## 🚀 进阶挑战

### 挑战1：返回最大子数组本身
不仅返回最大和，还要返回这个子数组 `[start, end]`。

**提示**：记录 `tempStart` 和更新 `start, end` 的时机。

### 挑战2：最大子数组乘积（LeetCode 152）
如果是求最大乘积而不是最大和，该如何修改？

**提示**：负数×负数可能变成最大值，需要同时维护最大值和最小值。

### 挑战3：允许删除一个元素
找出删除最多一个元素后的最大子数组和。

**提示**：维护两个状态：
- `dp0[i]`：未删除元素时，以 `nums[i]` 结尾的最大和
- `dp1[i]`：删除一个元素后，以 `nums[i]` 结尾的最大和

---

## ✅ 自检清单

- [ ] 我理解了什么是连续子数组
- [ ] 我知道暴力法为什么慢（O(n²)）
- [ ] 我理解了 DP 状态定义：以 `nums[i]` 结尾
- [ ] 我能写出状态转移方程
- [ ] 我理解了为什么可以用滚动变量优化空间
- [ ] 我知道这就是 Kadane's Algorithm
- [ ] 我能独立实现 O(n) 时间 O(1) 空间的解法

---

## 📌 核心要点

**口诀**：
> 遇到连续子数组，先想动态规划。  
> 状态定义很关键，以当前位置结尾。  
> 两种选择做决策，接上前面或重新开始。  
> 滚动变量省空间，Kadane 算法要记牢。

---

**下一步**：独立编码实现，然后对照 `solution.md` 验证！
