# 56. 合并区间

## 📝 题目描述

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：**
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，将它们合并为 [1,6]
```

**示例 2：**
```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间
```

**约束条件：**
- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 10^4`

---

## ⭐ 解法：排序 + 贪心

### 思路

**步骤**：
1. **排序**：按区间起始位置排序
2. **遍历合并**：
   - 如果当前区间与前一个区间重叠，合并
   - 否则，将当前区间加入结果

**判断重叠**：
```
区间1: [a, b]
区间2: [c, d]
重叠条件: c <= b
```

### 代码实现
```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};
        
        // 1. 按起始位置排序
        sort(intervals.begin(), intervals.end());
        
        vector<vector<int>> result;
        result.push_back(intervals[0]);
        
        // 2. 遍历合并
        for (int i = 1; i < intervals.size(); i++) {
            // 当前区间
            int start = intervals[i][0];
            int end = intervals[i][1];
            
            // 上一个区间
            int lastEnd = result.back()[1];
            
            if (start <= lastEnd) {
                // 重叠，合并
                result.back()[1] = max(lastEnd, end);
            } else {
                // 不重叠，直接加入
                result.push_back(intervals[i]);
            }
        }
        
        return result;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n log n)，排序
- **空间复杂度**：O(log n)，排序的栈空间

---

## 🎯 核心知识点

### 1. 区间重叠判断

```
区间1: [1, 5]
区间2: [3, 7]

重叠：3 <= 5 ✓
合并：[1, max(5, 7)] = [1, 7]
```

```
区间1: [1, 3]
区间2: [5, 7]

不重叠：5 > 3 ✗
```

### 2. 为什么要排序？

**排序前**：
```
[[2,6], [1,3], [8,10]]
难以判断哪些区间需要合并
```

**排序后**：
```
[[1,3], [2,6], [8,10]]
只需检查相邻区间是否重叠
```

### 3. 合并逻辑

```cpp
if (start <= lastEnd) {
    // 重叠：更新结束位置
    result.back()[1] = max(lastEnd, end);
}
```

**为什么用 max？**
```
情况1: [1,5] + [2,3]
合并: [1, max(5,3)] = [1,5]

情况2: [1,3] + [2,6]
合并: [1, max(3,6)] = [1,6]
```

---

## 🔍 图解过程

```
输入：[[1,3],[2,6],[8,10],[15,18]]

Step 1: 排序
[[1,3],[2,6],[8,10],[15,18]]

Step 2: 初始化
result = [[1,3]]

Step 3: 处理 [2,6]
[2,6] 的起始 2 <= 3 (重叠)
合并: [1, max(3,6)] = [1,6]
result = [[1,6]]

Step 4: 处理 [8,10]
[8,10] 的起始 8 > 6 (不重叠)
直接加入
result = [[1,6], [8,10]]

Step 5: 处理 [15,18]
[15,18] 的起始 15 > 10 (不重叠)
直接加入
result = [[1,6], [8,10], [15,18]]

最终结果：[[1,6], [8,10], [15,18]]
```

---

## 🎓 变式题目

### 1. 插入区间（LeetCode 57）
在已排序的区间列表中插入一个新区间。

### 2. 无重叠区间（LeetCode 435）
计算需要移除多少个区间才能使剩余区间不重叠。

### 3. 会议室II（LeetCode 253）
给定会议时间，求最少需要多少个会议室。

---

## 📌 记忆要点

- **步骤**：排序 → 遍历合并
- **重叠条件**：`start <= lastEnd`
- **合并方式**：`[lastStart, max(lastEnd, end)]`
- **复杂度**：O(n log n) 排序为瓶颈

---

**标签**：`数组` `排序` `区间` `medium`
