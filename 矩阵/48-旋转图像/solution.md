# 48. 旋转图像

## 题目描述

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**示例 1：**
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

---

## 解法：数学变换（转置 + 翻转）

### 核心思路
顺时针旋转 90 度可以分解为两个简单的步骤：
1. **转置矩阵**：将矩阵的行列互换（沿着主对角线翻转）。
2. **水平翻转**：将每一行进行左右翻转。

**推导**：
- 原坐标 `(i, j)`。
- 顺时针旋转 90 度后，应该变到 `(j, n-1-i)`。
- **转置**后：`(i, j)` -> `(j, i)`。
- **翻转**每一行后：`(j, i)` -> `(j, n-1-i)`。
正好对应！

### 代码实现

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 1. 转置矩阵
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) { // 注意 j 从 i+1 开始，只遍历上三角
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        
        // 2. 翻转每一行
        for (int i = 0; i < n; ++i) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

### 复杂度分析
- **时间复杂度**：O(N^2)。我们需要遍历整个矩阵两次。
- **空间复杂度**：O(1)。原地操作。

### 易错点
- 转置时内层循环 `j` 从 `i + 1` 开始，否则会换两次换回去。
- 必须是 `n x n` 的方阵才能这样原地转置。

---

## 总结
- 这是一个非常实用的线性代数技巧。
- 另一种方法是“由外向内”一圈圈旋转，但代码逻辑比较复杂（涉及 4 个点的坐标变换），不如“转置+翻转”简洁。
