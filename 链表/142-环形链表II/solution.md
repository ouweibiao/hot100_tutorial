# 142. 环形链表 II

## 题目描述

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

**不允许修改** 链表。

### 示例

**示例 1：**
```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**
```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

---

## 解法：快慢指针 + 数学推导

### 核心思路
1. **判断是否有环**：使用快慢指针，`fast` 走两步，`slow` 走一步。
2. **寻找入口**：
   - 如果相遇，说明有环。
   - 让其中一个指针（比如 `fast`）回到头节点 `head`。
   - 两个指针都每次走一步。
   - 再次相遇的点，就是环的入口。

### 为什么这样做是对的？
假设：
- `a`：从头节点到入环点的距离
- `b`：从入环点到相遇点的距离
- `c`：从相遇点回到入环点的距离
- 环的周长 `L = b + c`

当相遇时：
- `slow` 走了 `a + b`
- `fast` 走了 `a + b + k*L` （k为圈数，k>=1）
- `fast` 速度是 `slow` 的两倍：`2(a + b) = a + b + k*L`
- 化简得：`a + b = k*L`
- 移项：`a = k*L - b`
- 变形：`a = (k-1)L + (L - b)`
- 因为 `L = b + c`，所以 `L - b = c`
- 最终结论：**`a = (k-1)L + c`**

这意味着：**从头节点出发走 `a` 步，和从相遇点出发走 `c` 步（再加上几圈），最终会在入环点相遇！**

### 代码实现
```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            
            // 1. 相遇，说明有环
            if (slow == fast) {
                // 2. 寻找入口
                ListNode* ptr = head; // 一个从头开始
                while (ptr != slow) { // 一个从相遇点开始
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr; // 相遇点即为入口
            }
        }
        
        return nullptr;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)。
- **空间复杂度**：O(1)。

---

## 常见疑问

1. **为什么 slow 指针第一圈就会被 fast 追上？**
   - 只要 slow 进入环，fast 已经在环里了。
   - fast 相对 slow 的速度是 1，每次距离缩短 1。
   - 最多跑一圈环的长度就能追上。

2. **如果环很小，fast 会不会跳过 slow？**
   - 不会。这是离散数学的问题。
   - 相对距离每次减 1，一定会减到 0。

---

## 总结

- 这是一道经典的**数学题**。
- 记住结论：`x = z`（头到入口 = 相遇点到入口）。
- 面试时最好能画图解释这个推导过程。

---

**标签**：`链表` `双指针` `medium`
