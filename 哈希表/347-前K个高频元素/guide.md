# 347. 前 K 个高频元素

## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**进阶：** 你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

## 解题思路

### 1. 统计频率
首先，无论用什么方法，都需要先统计每个元素出现的次数。
- 使用哈希表 (`unordered_map<int, int>`)：`key` 为元素，`value` 为出现次数。
- 时间复杂度：O(n)。

### 2. 找出前 K 个高频元素
统计完频率后，问题转化为：**从 N 个数中找出最大的 K 个数**。

#### 方法一：小顶堆 (Min-Heap) —— 推荐通用解法
- 维护一个大小为 `k` 的**小顶堆**。
- 堆顶是目前这 k 个数中频率最小的。
- 遍历所有元素：
  - 如果堆大小 < k，直接入堆。
  - 如果堆大小 == k，且当前元素频率 > 堆顶频率：
    - 弹出堆顶（淘汰最小的）。
    - 将当前元素入堆。
- 最终堆中剩下的就是频率最高的 k 个元素。
- **复杂度**：O(n log k)。优于 O(n log n)。

#### 方法二：桶排序 (Bucket Sort) —— 极客解法
- 既然频率最大不会超过数组长度 `n`，我们可以创建一个数组（桶），下标表示频率，值表示出现该频率的元素列表。
- `vector<vector<int>> buckets(n + 1)`
- 将元素按频率放入对应的桶中。
- 从后往前（高频率向低频率）遍历桶，取出 k 个元素即可。
- **复杂度**：O(n)。

## 总结
- **小顶堆**：适合海量数据（如流式数据），内存占用小（只存 k 个）。
- **桶排序**：适合数据量确定且频率范围有限的情况，速度最快 O(n)。
