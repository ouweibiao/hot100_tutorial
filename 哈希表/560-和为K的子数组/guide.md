# 560. 和为 K 的子数组

## 🧠 解题思路引导

### 1. 暴力法（Naive）
- 枚举所有可能的子数组 `[i...j]`。
- 计算它们的和。
- 如果和等于 K，计数器加一。
- 复杂度：`O(n^3)` 或 `O(n^2)`（如果利用前缀和优化）。
- 题目数据范围 `nums.length <= 2 * 10^4`，`O(n^2)` 可能会超时。

### 2. 前缀和（Prefix Sum）
- 定义 `pre[i]` 为 `nums[0]...nums[i]` 的和。
- 那么子数组 `nums[j...i]` 的和可以表示为 `pre[i] - pre[j-1]`。
- 题目转化为：寻找 `i` 和 `j`，使得 `pre[i] - pre[j-1] == K`。
- 移项得：`pre[j-1] == pre[i] - K`。

### 3. 哈希表优化（Hash Map）
- 当我们遍历到 `i` 时，我们已经知道了 `pre[i]`。
- 我们需要找之前有多少个 `j`，满足 `pre[j-1] == pre[i] - K`。
- 也就是问：**在 `i` 之前，有多少个前缀和的值等于 `pre[i] - K`？**
- 我们可以用一个哈希表 `mp` 记录：
  - Key: 前缀和的值
  - Value: 这个前缀和出现的次数
- 边遍历，边查询，边更新哈希表。
