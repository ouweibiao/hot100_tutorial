# 128. 最长连续序列

## 📝 题目描述

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**
```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**
```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**约束条件：**
- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

## ⭐ 解法：哈希表 + 智能扫描

### 思路

**核心观察**：
- 只从序列的起始数字开始扫描
- 如果 `num-1` 存在，说明 `num` 不是起始数字，跳过

**步骤**：
1. 将所有数字放入哈希表（去重 + O(1)查找）
2. 遍历数组，对每个数字：
   - 如果 `num-1` 不存在，说明是序列起点
   - 从这个起点开始，依次查找 `num+1, num+2, ...`
   - 统计连续序列长度

### 代码实现
```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> numSet(nums.begin(), nums.end());
        int maxLength = 0;
        
        for (int num : numSet) {
            // 只从序列起点开始扫描
            if (numSet.count(num - 1)) {
                continue;  // num-1 存在，跳过
            }
            
            // num 是序列起点，开始向后扫描
            int currentNum = num;
            int currentLength = 1;
            
            while (numSet.count(currentNum + 1)) {
                currentNum++;
                currentLength++;
            }
            
            maxLength = max(maxLength, currentLength);
        }
        
        return maxLength;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)
  - 虽然有嵌套循环，但每个数字最多被访问2次（一次外层，一次内层）
  - 总操作次数 ≤ 2n
- **空间复杂度**：O(n)，哈希表

---

## 🎯 核心知识点

### 1. 为什么是 O(n)？

**关键**：每个数字最多被访问常数次

```
nums = [4, 1, 3, 2]

遍历1: 访问 4
  4-1=3 存在，跳过

遍历2: 访问 1
  1-1=0 不存在，是起点
  扫描: 1→2→3→4 (4个数字被访问一次)

遍历3: 访问 3
  3-1=2 存在，跳过

遍历4: 访问 2
  2-1=1 存在，跳过

总访问次数: 4(外层) + 4(内层) = 8 次 ≤ 2n
```

### 2. 智能扫描策略

**朴素方法**（会超时）：
```cpp
for (int num : nums) {
    int length = 1;
    while (numSet.count(num + length)) {
        length++;
    }
}
// 每个数字都从自己开始扫描，重复了！
```

**优化方法**：
```cpp
if (numSet.count(num - 1)) continue;  // 不是起点，跳过
// 只从起点开始扫描，避免重复
```

### 3. 哈希表的作用

- **去重**：相同数字只保留一个
- **O(1) 查找**：快速判断某个数字是否存在

---

## 🔍 图解过程

```
nums = [100, 4, 200, 1, 3, 2]
numSet = {1, 2, 3, 4, 100, 200}

遍历 100:
  100-1=99 不在 set 中，是起点
  扫描: 100 (没有101)
  长度: 1

遍历 4:
  4-1=3 在 set 中，跳过

遍历 200:
  200-1=199 不在 set 中，是起点
  扫描: 200 (没有201)
  长度: 1

遍历 1:
  1-1=0 不在 set 中，是起点 ✓
  扫描: 1→2→3→4 (依次查找 2,3,4,5)
  长度: 4 ← 最长

遍历 3:
  3-1=2 在 set 中，跳过

遍历 2:
  2-1=1 在 set 中，跳过

最长序列长度: 4
```

---

## 🎓 变式题目

### 1. 最长连续递增序列（LeetCode 674）
找数组中最长的连续递增子序列。

**区别**：必须是原数组中连续的。

### 2. 缺失的第一个正数（LeetCode 41）
找数组中缺失的最小正整数。

---

## 📌 记忆要点

- **哈希表**：O(1) 查找 + 去重
- **优化关键**：只从序列起点开始扫描
- **判断起点**：`num-1` 不存在
- **复杂度**：O(n) 时间，每个数最多访问2次

---

## 🔨 常见错误

### 错误1：重复扫描
```cpp
// ❌ 错误：从每个数字都开始扫描
for (int num : nums) {
    int length = 0;
    while (numSet.count(num + length)) {
        length++;
    }
}
// 时间复杂度会退化到 O(n²)

// ✅ 正确：只从起点开始
if (!numSet.count(num - 1)) {
    // 扫描...
}
```

### 错误2：忘记去重
```cpp
// ❌ 错误：直接遍历 nums，可能有重复
for (int num : nums) {
    if (!numSet.count(num - 1)) { ... }
}

// ✅ 正确：遍历 set
for (int num : numSet) {
    if (!numSet.count(num - 1)) { ... }
}
```

---

**标签**：`数组` `哈希表` `medium`
