# 146. LRU 缓存

## 题目描述

请你设计并实现一个满足 **LRU (最近最少使用) 缓存** 约束的数据结构。

实现 `LRUCache` 类：
- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 **O(1)** 的平均时间复杂度运行。

## 解题思路

### 核心难点
1. **O(1) 查询**：必须使用哈希表（Hash Map）。
2. **O(1) 插入/删除/移动**：必须使用双向链表（Doubly Linked List）。
3. **维护顺序**：
   - 每次 `get` 或 `put` 一个已存在的元素，都需要将其移动到链表头部（表示最近使用）。
   - 当容量满时，需要删除链表尾部的元素（表示最久未使用）。

### 数据结构设计
我们需要结合 **哈希表** 和 **双向链表**：
- **哈希表 (`unordered_map`)**：存储 `key` 到 `链表节点` 的映射，实现 O(1) 查找。
- **双向链表 (`list` 或 手写)**：存储 `key-value` 对，链表头部是最近使用的，尾部是最久未使用的。

### 为什么用双向链表？
因为我们需要在 O(1) 时间内删除链表中的任意节点（通过哈希表找到节点指针），并将其移动到头部。单向链表删除节点需要前驱节点，无法在 O(1) 内完成（除非拷贝值，但这里节点是对象）。

### C++ STL 神器：`std::list`
C++ 的 `std::list` 是一个双向链表。它有一个非常强大的方法 `splice`，可以将一个节点从链表的一个位置移动到另一个位置（或另一个链表），且时间复杂度为 O(1)。
- `list.splice(list.begin(), list, iterator)`：将 `iterator` 指向的节点移动到 `list` 的头部。

### 算法流程
1. **Get(key)**:
   - 查哈希表，如果不存在返回 -1。
   - 如果存在，通过哈希表拿到链表迭代器。
   - 将该节点移动到链表头部（更新活跃度）。
   - 返回 value。

2. **Put(key, value)**:
   - 查哈希表，如果存在：
     - 更新 value。
     - 将该节点移动到链表头部。
   - 如果不存在：
     - 如果容量已满：
       - 删除链表尾部节点（最久未使用）。
       - 删除哈希表中对应的 key。
     - 在链表头部插入新节点。
     - 在哈希表中记录 `key` -> `链表头部迭代器`。
