# 131. 分割回文串

## 题目描述

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**示例 1：**
```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

## 解题思路

### 方法：回溯 + 动态规划预处理
- **核心**：典型的切割问题。我们需要在不同的位置切开字符串。
- **递归函数**：`backtrack(index)`
  - `index`：当前切割的起始位置。
  - 循环变量 `i` 从 `index` 到 `s.size() - 1`：
    - 截取子串 `sub = s[index...i]`。
    - 判断 `sub` 是否为回文串。
    - 如果是，加入 `path`，递归 `backtrack(i + 1)`，然后回溯。
- **优化**：判断回文串可以用动态规划预处理，生成一个二维数组 `dp[i][j]` 表示 `s[i...j]` 是否为回文串，从而将判断时间降为 O(1)。
  - `dp[i][j] = (s[i] == s[j]) && (j - i <= 2 || dp[i+1][j-1])`。

## 复杂度
- 时间复杂度：O(N * 2^N)。最坏情况下有 2^N 种分割方案。
- 空间复杂度：O(N^2) 用于 DP 表，递归栈 O(N)。
