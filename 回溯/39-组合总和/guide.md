# 39. 组合总和

## 题目描述

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 `target` 的不同组合数少于 150 个。

## 解题思路

### 方法：回溯 (Backtracking)
- **核心思想**：
  - 类似于全排列或子集问题，我们从数组中选择数字。
  - 由于可以重复选择，我们在递归下一层时，`start` 索引保持不变（允许再次选择当前数字）。
  - **剪枝**：
    - 如果当前和 `currentSum > target`，直接返回。
    - 为了优化，可以先对数组排序，这样当 `currentSum + candidates[i] > target` 时，后面的数字更大，肯定也不行，可以直接 `break` 循环。
- **状态定义**：
  - `backtrack(start, currentSum, path)`
  - `start`：当前可以从哪个索引开始选（避免产生重复组合，如 [2,3] 和 [3,2]）。
  - `currentSum`：当前路径的和。
  - `path`：当前选择的数字列表。

## 复杂度
- 时间复杂度：O(S)，S 为所有可行解的长度之和。最坏情况下是指数级，但剪枝后实际运行很快。
- 空间复杂度：O(target / min(candidates))，递归栈的深度。
