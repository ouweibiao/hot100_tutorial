# 79. 单词搜索

## 题目描述

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

## 解题思路

### 方法：DFS (回溯)
- **核心**：在网格图中进行深度优先搜索。
- **流程**：
  - 遍历网格中的每一个点 `(i, j)` 作为起点。
  - 调用 `check(i, j, k)`，判断从 `(i, j)` 开始能否匹配 `word` 从第 `k` 个字符开始的后缀。
  - **Check 函数**：
    - 边界检查：越界返回 false。
    - 字符匹配：`board[i][j] != word[k]` 返回 false。
    - 终止条件：`k == word.size() - 1`，说明匹配成功，返回 true。
    - 递归：
      - 标记当前位置已访问（例如修改为特殊字符 '#' 或使用 `visited` 数组）。
      - 向上下左右四个方向递归 `check(new_i, new_j, k + 1)`。
      - 如果任意一个方向返回 true，则返回 true。
      - **回溯**：将当前位置恢复为原来的字符。

## 复杂度
- 时间复杂度：O(M * N * 3^L)，L 是单词长度。每个格子有 4 个方向，但不能走回头路，所以是 3 个方向。
- 空间复杂度：O(L)，递归栈深度。
