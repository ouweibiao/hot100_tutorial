# 28. 找出字符串中第一个匹配项的下标 (KMP算法)

## 题目描述

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回  `-1` 。

**示例 1：**
```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

## 解题思路

### 方法一：暴力匹配 (Brute Force)
- 双重循环。
- 时间复杂度：O(M * N)。
- 空间复杂度：O(1)。

### 方法二：KMP 算法 (Knuth-Morris-Pratt) —— 进阶必会
- **核心思想**：当出现字符串不匹配时，可以知道一部分已经匹配的文本内容，利用这些信息避免从头再去做匹配。
- **前缀表 (Next 数组)**：记录下标 `i` 之前（包括 `i`）的字符串中，有多大长度的**相同前缀后缀**。
  - 例如 "aabaaf"，对应的 next 数组是 `[0, 1, 0, 1, 2, 0]`。
- **匹配流程**：
  1. 构建 `needle` 的 next 数组。
  2. 遍历 `haystack` (指针 `i`) 和 `needle` (指针 `j`)。
  3. 当 `haystack[i] == needle[j]`，双指针后移。
  4. 当不匹配时，`j` 回退到 `next[j-1]` 的位置，`i` 不回退。
- **复杂度**：
  - 时间复杂度：O(M + N)。
  - 空间复杂度：O(N) (Next 数组)。

## 总结
KMP 是 ACM 和大厂面试（尤其是字节跳动、腾讯）的高频考点，虽然很难背，但理解原理后非常强大。
