# 76. 最小覆盖子串

## 题目描述

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**
- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**
```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

## 解题思路

### 方法：滑动窗口 (Sliding Window)
这道题是 **438. 找到字符串中所有字母异位词** 的进阶版，也是滑动窗口最经典的困难题。

#### 核心步骤
1. **定义窗口**：`[left, right)`，左闭右开区间。
2. **扩大窗口**：不断增加 `right`，直到窗口中的字符包含了 `t` 中所有的字符（即满足条件）。
3. **缩小窗口**：一旦满足条件，停止增加 `right`，开始增加 `left`（缩小窗口），试图找到更小的满足条件的窗口。直到窗口不再满足条件。
4. **重复**：再次扩大窗口，直到满足条件...

#### 数据结构
- `need` 哈希表：记录 `t` 中每个字符需要的数量。
- `window` 哈希表：记录当前窗口中每个字符出现的数量。
- `valid` 变量：记录窗口中已经满足要求的字符种类数（用于快速判断是否满足条件，避免遍历哈希表）。

#### 流程细节
1. 初始化 `left = 0`, `right = 0`。
2. 只要 `right < s.size()`：
   - 取出 `c = s[right]`，`right++`。
   - 更新 `window` 数据。如果 `window[c]` 达到 `need[c]`，则 `valid++`。
   - **当 `valid == need.size()` 时**（说明窗口已满足条件）：
     - 更新最小覆盖子串的起始位置和长度。
     - 取出 `d = s[left]`，`left++`。
     - 更新 `window` 数据。如果 `window[d]` 低于 `need[d]`，则 `valid--`。

## 复杂度
- **时间复杂度**：O(N)，其中 N 是 `s` 的长度。虽然有两层循环（外层 right，内层 left），但 `left` 和 `right` 都最多只会从 0 走到 N，没有回退。
- **空间复杂度**：O(C)，C 是字符集大小（这里是 ASCII 128 或 256）。
