# 55. 跳跃游戏

## 题目描述

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。

**示例 1：**
```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**
```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

---

## 解法：贪心算法

### 核心思路
我们不需要纠结具体怎么跳（比如是跳 1 步还是跳 2 步），我们只需要关注：**在当前位置，我最远能覆盖到哪里**。

1. 维护一个变量 `maxReach`，表示**当前能到达的最远下标**。
2. 遍历数组，对于每个位置 `i`：
   - 首先检查 `i` 是否在 `maxReach` 范围内。如果 `i > maxReach`，说明当前位置都无法到达，更别说后面的了，直接返回 `false`。
   - 如果 `i` 可达，则更新 `maxReach`：`maxReach = max(maxReach, i + nums[i])`。
   - 如果在遍历过程中，`maxReach` 已经大于等于最后一个下标，说明可以到达终点，返回 `true`。

### 代码实现

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int maxReach = 0; // 当前能到达的最远位置
        
        for (int i = 0; i < n; ++i) {
            // 如果当前位置已经不可达，说明中间断开了
            if (i > maxReach) {
                return false;
            }
            // 更新最远能到达的位置
            maxReach = max(maxReach, i + nums[i]);
            
            // 如果已经能到达终点，提前结束
            if (maxReach >= n - 1) {
                return true;
            }
        }
        
        return false;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，遍历一次数组。
- **空间复杂度**：O(1)，只使用了常数个变量。

### 易错点
- 循环条件可以是 `i <= maxReach`，这样就不需要显式判断 `i > maxReach`。
- 注意题目说的是“能否到达”，不是“刚好到达”，所以 `maxReach >= n - 1` 即可。

---

## 总结
- **贪心思想**：每次都取局部最优（跳得最远），看能否覆盖全局。
- 只要覆盖范围能覆盖到终点，就一定能一步步跳过去。
