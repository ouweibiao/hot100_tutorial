# 45. 跳跃游戏 II

## 题目描述

给定一个长度为 `n` 的 0 索引整数数组 `nums`。初始位置为 `nums[0]`。
每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。
换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处，其中:
- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例 1:**
```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

---

## 解法：贪心算法

### 核心思路
我们需要求最小跳跃次数，这意味着我们要尽可能每一跳都跳得更远。但不是盲目跳最远，而是看**这一跳能覆盖的范围内，下一跳最远能到哪里**。

我们可以维护两个变量：
1. `end`：当前这一步跳跃能到达的边界。
2. `maxPos`：在当前这一步的范围内，下一步能到达的最远位置。

**算法流程**：
- 遍历数组（注意只需要遍历到 `n-2`，因为进入最后一格就不需要再跳了）。
- 对于每个位置 `i`，更新 `maxPos = max(maxPos, i + nums[i])`。
- 如果遍历到了当前边界 `end`：
  - 说明必须要进行下一次跳跃了，步数 `steps + 1`。
  - 更新边界 `end = maxPos`（下一次跳跃的边界就是刚才计算出的最远位置）。

### 代码实现

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return 0; // 只有一个元素，不需要跳
        
        int end = 0;    // 当前跳跃的边界
        int maxPos = 0; // 下一步能到达的最远位置
        int steps = 0;  // 跳跃次数
        
        // 注意：只遍历到 n-2。因为如果 i 到达 n-1，我们不需要再跳了。
        for (int i = 0; i < n - 1; ++i) {
            maxPos = max(maxPos, i + nums[i]);
            
            // 到达了当前步的边界
            if (i == end) {
                end = maxPos; // 更新边界
                steps++;      // 步数加一
            }
        }
        
        return steps;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，遍历一次数组。
- **空间复杂度**：O(1)。

### 易错点
- **循环边界**：循环只需要走到 `n-2`。因为当我们到达 `n-1` 时，已经算作到达终点，不需要再增加步数。如果循环走到 `n-1`，并且 `end` 刚好在 `n-1`，会导致步数多加一次。
- **初始检查**：如果数组长度为 1，直接返回 0。

---

## 总结
- 相比于 55 题的“能否到达”，这道题是求“最小步数”。
- 核心在于隐式地构建了 BFS 的层级，每次 `end` 的更新就相当于进入了下一层。
