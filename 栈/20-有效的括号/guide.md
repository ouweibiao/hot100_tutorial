# 20. 有效的括号 - 渐进式学习指南

> 💡 **学习目标**：理解栈的应用，掌握括号匹配的经典算法

---

## 🎯 问题理解

### 核心问题
判断字符串中的括号是否正确匹配。

### 示例分析
```
✅ "()"     → 有效
✅ "()[]{}" → 有效
❌ "(]"     → 无效（类型不匹配）
❌ "([)]"   → 无效（顺序错误）
✅ "{[]}"   → 有效（嵌套正确）
```

### 关键观察
1. 左括号需要等待**对应的**右括号
2. 右括号应该匹配**最近的**左括号
3. 所有括号最终都应该被匹配

---

## 💭 思考引导

在查看提示前，先思考以下问题：

### 问题1：用什么数据结构？
如果你要记录"等待匹配的左括号"，应该用什么数据结构？

<details>
<summary>💡 提示</summary>

想象这样的场景：
```
"((()))"
遇到第1个(：记住它
遇到第2个(：也记住它
遇到第3个(：继续记住
遇到第1个)：应该匹配最近的(（第3个）
```

**关键词**：**最近的**、**后进先出** → 栈！

</details>

### 问题2：如何判断匹配？
遇到右括号时，如何知道它应该匹配哪个左括号？

<details>
<summary>💡 提示</summary>

**规则**：
- 看到 `)`，应该匹配 `(`
- 看到 `]`，应该匹配 `[`
- 看到 `}`，应该匹配 `{`

**方法**：用**字典/哈希表**存储配对关系
```cpp
unordered_map<char, char> pairs = {
    {')', '('}, 
    {']', '['}, 
    {'}', '{'}
};
```

</details>

### 问题3：有哪些失败情况？
什么情况下括号不匹配？

<details>
<summary>💡 提示</summary>

**三种失败情况**：
1. ❌ **栈空时遇到右括号**：如 `"))("`
2. ❌ **类型不匹配**：如 `"(]"`
3. ❌ **遍历结束栈不为空**：如 `"((("`

</details>

---

## 📚 渐进式提示

### Level 1：理解栈的特性 ⭐

<details>
<summary>点击查看</summary>

#### 什么是栈？

**栈（Stack）**：后进先出（LIFO）的数据结构

**生活类比**：
- 盘子堆：最后放上去的盘子，最先被拿走
- 羽毛球筒：最后放进的球，最先被打出

#### C++中的栈操作

```cpp
#include <stack>
using namespace std;

stack<int> st;

// 入栈
st.push(1);    // [1]
st.push(2);    // [1, 2]
st.push(3);    // [1, 2, 3]

// 出栈
st.pop();      // st=[1, 2] (无返回值)

// 查看栈顶（不删除）
int top = st.top();  // top=2

// 判断栈空
bool is_empty = st.empty();
```

#### 为什么用栈？

**括号匹配的特点**：
```
"{[()]}"
       ↑
       最内层的()先匹配
     ↑
     然后[]匹配
   ↑
   最后{}匹配
```

**"最近的先匹配"** = **"后进先出"** → 完美契合栈！

</details>

---

### Level 2：匹配过程模拟 ⭐⭐

<details>
<summary>点击查看</summary>

#### 手动模拟

**示例1**：`s = "([])"`

```
步骤  | 当前字符 | 操作      | 栈状态
-----|---------|----------|--------
1    | (       | 入栈      | [(]
2    | [       | 入栈      | [(, []
3    | ]       | 匹配[     | [(]
4    | )       | 匹配(     | []

结果：栈空 → ✅ 有效
```

**示例2**：`s = "([)]"`

```
步骤  | 当前字符 | 操作      | 栈状态
-----|---------|----------|--------
1    | (       | 入栈      | [(]
2    | [       | 入栈      | [(, []
3    | )       | 应该匹配[ | ❌ 失败！
                | 但实际是( |

结果：类型不匹配 → ❌ 无效
```

**示例3**：`s = "(("`

```
步骤  | 当前字符 | 操作      | 栈状态
-----|---------|----------|--------
1    | (       | 入栈      | [(]
2    | (       | 入栈      | [(, (]

结果：栈不为空 → ❌ 无效（有未匹配的左括号）
```

#### 算法流程图

```
开始
 ↓
创建空栈和配对哈希表
 ↓
遍历每个字符
 ↓
是右括号？
├─ 是 → 栈空？
│       ├─ 是 → 返回False
│       └─ 否 → 栈顶匹配？
│               ├─ 是 → 出栈
│               └─ 否 → 返回False
└─ 否 → 入栈（左括号）
 ↓
遍历结束
 ↓
栈是否为空？
├─ 是 → 返回True
└─ 否 → 返回False
```

</details>

---

### Level 3：代码实现 ⭐⭐⭐

<details>
<summary>点击查看</summary>

#### 完整代码

```cpp
bool isValid(string s) {
    // 1. 创建栈
    stack<char> st;
    
    // 2. 创建配对哈希表（右括号→左括号）
    unordered_map<char, char> pairs = {
        {')', '('},
        {']', '['},
        {'}', '{'}
    };
    
    // 3. 遍历每个字符
    for (char ch : s) {
        if (pairs.count(ch)) {  // 右括号
            // 检查栈顶是否匹配
            if (st.empty() || st.top() != pairs[ch]) {
                return false;
            }
            st.pop();
        } else {  // 左括号
            st.push(ch);
        }
    }
    
    // 4. 检查栈是否为空
    return st.empty();
}
```

#### 代码详解

**关键点1**：配对哈希表
```cpp
unordered_map<char, char> pairs = {{')', '('}, {']', '['}, {'}', '{'}};
// 右括号作为key，方便查询应该匹配的左括号
```

**关键点2**：判断右括号
```cpp
if (pairs.count(ch)) {  // 是右括号
    // 检查两个条件：
    // 1. 栈不为空
    // 2. 栈顶是对应的左括号
    if (st.empty() || st.top() != pairs[ch]) {
        return false;
    }
    st.pop();
}
```

**关键点3**：最后检查栈
```cpp
return st.empty();
```

#### 执行轨迹

```text
s = "([)]"

char='(': 左括号 → 入栈 → stack=['(']
char='[': 左括号 → 入栈 → stack=['(', '[']
char=')': 右括号 → 检查栈顶='['，应该匹配'(' → 不匹配 → 返回False
```

</details>

---

### Level 4：优化与扩展 ⭐⭐⭐⭐

<details>
<summary>点击查看</summary>

#### 优化1：提前判断长度

```cpp
bool isValid(string s) {
    // 奇数长度必然无效
    if (s.length() % 2 != 0) {
        return false;
    }
    
    // ... 其他逻辑
}
```

#### 优化2：更简洁的写法

```cpp
bool isValid(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == '(') st.push(')');
        else if (c == '{') st.push('}');
        else if (c == '[') st.push(']');
        else if (st.empty() || st.top() != c) return false;
        else st.pop();
    }
    return st.empty();
}
```

#### 扩展：统计需要添加的括号数

**问题**：需要添加多少个括号才能使字符串有效？

```cpp
int minAddToMakeValid(string s) {
    int left_need = 0;   // 需要添加的左括号
    int right_need = 0;  // 需要添加的右括号
    
    for (char ch : s) {
        if (ch == '(') {
            right_need += 1;  // 每个(需要一个)
        } else {  // ch == ')'
            if (right_need > 0) {
                right_need -= 1;  // 匹配了一个(
            } else {
                left_need += 1;   // 需要补一个(
            }
        }
    }
    
    return left_need + right_need;
}

// 测试
// cout << minAddToMakeValid("())") << endl;   // 1，需要加1个(
// cout << minAddToMakeValid("(((") << endl;   // 3，需要加3个)
```

#### 扩展：支持通配符

**问题**：字符串包含 `*`，可以当作 `(`、`)` 或空，判断是否有效

```cpp
bool checkValidString(string s) {
    // 记录可能的左括号数量范围
    int lo = 0, hi = 0;
    
    for (char ch : s) {
        if (ch == '(') {
            lo += 1;
            hi += 1;
        } else if (ch == ')') {
            lo = max(0, lo - 1);
            hi -= 1;
        } else {  // ch == '*'
            lo = max(0, lo - 1);  // 当作)
            hi += 1;               // 当作(
        }
        
        if (hi < 0) {
            return false;
        }
    }
    
    return lo == 0;
}
```

</details>

---

## 🔨 动手实践

### 任务1：手动模拟
在纸上模拟以下字符串的匹配过程：
- `"({[]})"`
- `"([}}])"`
- `"((()"`

### 任务2：实现基础版本
```cpp
bool isValid(string s) {
    // TODO: 实现括号匹配
    return false;
}

// 测试
// assert(isValid("()") == true);
// assert(isValid("()[]{}") == true);
// assert(isValid("(]") == false);
// assert(isValid("([)]") == false);
// assert(isValid("{[]}") == true);
```

### 任务3：添加调试功能
```cpp
bool isValid_debug(string s) {
    stack<char> st;
    unordered_map<char, char> pairs = {{')', '('}, {']', '['}, {'}', '{'}};
    
    for (int i = 0; i < s.length(); i++) {
        char ch = s[i];
        cout << "Step " << i+1 << ": char='" << ch << "'";
        // TODO: 完成逻辑并添加详细输出
    }
    
    return st.empty();
}

// 测试
// isValid_debug("([)]");
```

### 任务4：统计需要添加的括号
```cpp
int minAddToMakeValid(string s) {
    // TODO: 实现
    return 0;
}

// 测试
// assert(minAddToMakeValid("())") == 1);
// assert(minAddToMakeValid("(((") == 3);
```

---

## ✅ 自我检查清单

完成以下检查后，再查看完整解答：

- [ ] 理解栈的"后进先出"特性
- [ ] 知道为什么用栈解决括号匹配
- [ ] 能手动模拟匹配过程
- [ ] 理解配对字典的作用
- [ ] 掌握三种失败情况
- [ ] 能独立实现完整代码
- [ ] 理解时间和空间复杂度
- [ ] 能解释边界情况的处理

---

## 🎓 知识拓展

### 1. 栈的其他应用

- **表达式求值**：中缀转后缀
- **函数调用栈**：递归的底层实现
- **浏览器历史**：前进/后退功能
- **编辑器撤销**：Ctrl+Z功能

### 2. 括号匹配的变式

| 问题 | 特点 | 难度 |
|------|------|------|
| 基础括号匹配 | 三种括号 | ⭐ |
| 最少添加括号 | 统计数量 | ⭐⭐ |
| 括号字符串最大嵌套深度 | 统计深度 | ⭐⭐ |
| 有效括号字符串（含*） | 通配符 | ⭐⭐⭐ |

### 3. 实际应用

- **代码编辑器**：括号高亮匹配
- **编译器**：语法检查
- **HTML解析**：标签匹配
- **数学表达式**：括号验证

---

## 🚀 进阶挑战

### 挑战1：括号的分数
给定有效括号字符串，计算分数：
- `()` = 1
- `(A)` = 2 * A的分数
- `AB` = A的分数 + B的分数

### 挑战2：删除无效的括号
给定字符串，删除最少数量的无效括号，使其有效。

### 挑战3：括号的最大嵌套深度
计算有效括号字符串的最大嵌套深度。

---

## 💡 常见错误

### 错误1：忘记检查栈空
```cpp
// ❌ 错误
if (st.top() != pairs[ch]) {  // 栈空时会报错（Undefined Behavior）

// ✅ 正确
if (st.empty() || st.top() != pairs[ch]) {
```

### 错误2：字典的key和value搞反
```cpp
// ❌ 错误
unordered_map<char, char> pairs = {{'(', ')'}, {'[', ']'}, {'{', '}'}};  // 左→右

// ✅ 正确
unordered_map<char, char> pairs = {{')', '('}, {']', '['}, {'}', '{'}};  // 右→左
```

### 错误3：忘记最后检查栈
```cpp
// ❌ 错误：遍历结束就返回True

// ✅ 正确：还需要检查栈是否为空
return st.empty();
```

---

## 📖 学习建议

1. **理解栈的本质**：后进先出（LIFO）
2. **手动模拟过程**：在纸上画出栈的变化
3. **记住三种失败情况**
4. **练习变式题目**：加深理解
5. **思考实际应用**：代码编辑器、编译器等

完成这些后，查看 `solution.md` 获取完整解答！🎉
