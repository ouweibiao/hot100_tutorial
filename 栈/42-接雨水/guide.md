# 42. 接雨水

## 题目描述

给定 `n` 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1:**
![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

## 解题思路

### 方法一：单调栈 (Monotonic Stack)
- 类似于 [84. 柱状图中最大的矩形](../84-柱状图中最大的矩形/guide.md)。
- **核心**：积水只能在低洼处形成。我们需要寻找一个 **"凹槽"**。
- **凹槽**：左边有墙，右边有墙，中间低。
- **维护单调递减栈**：
  - 如果当前高度 `h[i]` < 栈顶高度：入栈（还没形成右墙）。
  - 如果当前高度 `h[i]` > 栈顶高度：
    - 说明 `h[i]` 是右墙，栈顶是坑底，栈顶下面那个元素是左墙。
    - 弹出栈顶 `bottom`。
    - 如果栈空了（没有左墙），接不住水，break。
    - 计算水量：
      - `width = i - left - 1`
      - `height = min(h[left], h[i]) - h[bottom]`
      - `ans += width * height`
- 这种方法是一层一层横向计算水量的。

### 方法二：双指针 (Two Pointers) —— 最优解
- **核心**：每一列能接多少水，取决于**它左边最高的墙**和**它右边最高的墙**中较矮的那个。
  - `water[i] = min(max_left, max_right) - height[i]`
- **优化**：
  - 维护两个指针 `left`, `right` 和两个变量 `left_max`, `right_max`。
  - 如果 `height[left] < height[right]`：
    - 说明瓶颈肯定在左边（因为右边哪怕有更高的也没用，已经被当前的 `height[right]` 限制了，或者 `height[right]` 本身就是右边最高的之一，反正左边是短板）。
    - 更新 `left_max`，计算 `left` 位置的水量，`left++`。
  - 否则：
    - 瓶颈在右边。
    - 更新 `right_max`，计算 `right` 位置的水量，`right--`。
- 时间 O(N)，空间 O(1)。

## 总结
面试中，双指针法写起来最快且空间最优。但单调栈的思想非常通用，也建议掌握。
