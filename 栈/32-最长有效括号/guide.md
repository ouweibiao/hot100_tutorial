# 32. 最长有效括号

## 题目描述

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1:**
```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2:**
```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

## 解题思路

### 方法一：栈 (Stack)
- **核心思想**：栈不仅仅用来判断匹配，还可以用来**记录下标**，从而计算长度。
- **技巧**：
  1. 保持栈底元素为**当前已经遍历过的元素中，最后一个没有被匹配的右括号的下标**。
  2. 初始化：栈中预先放入 `-1`。这充当一个"参照物"，用于计算从开头开始的有效长度。
- **流程**：
  - 遇到 `(`：将其下标入栈。
  - 遇到 `)`：
    - 弹出栈顶（匹配掉一个左括号）。
    - 此时如果栈为空：
      - 说明当前的 `)` 没有匹配的左括号，它成为了新的"分割点"。
      - 将当前 `)` 的下标入栈，作为新的栈底参照物。
    - 如果栈不为空：
      - 说明匹配成功。
      - 当前有效长度 = `当前下标 i - 栈顶元素下标`。
      - 更新最大长度。

### 方法二：动态规划 (DP)
- `dp[i]` 表示以 `i` 结尾的最长有效括号长度。
- 如果 `s[i] == '('`，`dp[i] = 0`。
- 如果 `s[i] == ')'`：
  - 情况 1：`s[i-1] == '('` (形如 `...()`) -> `dp[i] = dp[i-2] + 2`
  - 情况 2：`s[i-1] == ')'` (形如 `...))`)，且 `s[i - dp[i-1] - 1] == '('` -> `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`

### 方法三：不需要栈和DP (贪心/计数)
- 从左向右扫描，记录 `left` 和 `right` 个数。
  - `left == right` -> 更新 maxLen = 2 * right。
  - `right > left` -> `left = right = 0` (非法，重置)。
- 仅一次扫描漏掉 `((()` 这种情况，所以需要**从右向左**再扫一遍。
  - `left == right` -> 更新 maxLen。
  - `left > right` -> `left = right = 0`。
- 空间复杂度 O(1)，时间 O(N)。

## 推荐
面试中推荐**栈**方法，逻辑最清晰，不易出错。DP 方法状态转移较繁琐。
