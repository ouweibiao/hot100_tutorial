# 70. 爬楼梯 - 编程指导

## 🎯 学习目标
- 理解动态规划的基本思想
- 掌握状态转移方程的推导
- 学会空间优化技巧

---

## 📖 题目回顾

爬 n 阶楼梯，每次可以爬 1 或 2 阶，有多少种方法？

**示例**：
```
n = 3
方法：[1,1,1], [1,2], [2,1]
答案：3
```

---

## 💭 思考提示（分4级）

### 🌟 提示 Level 1：找规律
<details>
<summary>点击查看提示1</summary>

**手动计算小规模情况**：

```
n = 1:
  方法：[1]
  数量：1

n = 2:
  方法：[1,1], [2]
  数量：2

n = 3:
  方法：[1,1,1], [1,2], [2,1]
  数量：3

n = 4:
  方法：[1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2]
  数量：5

n = 5:
  数量：8
```

**发现规律**：
```
n:    1  2  3  4  5
方法: 1  2  3  5  8
```

这不就是斐波那契数列吗！

</details>

---

### 🌟 提示 Level 2：推导状态转移
<details>
<summary>点击查看提示2</summary>

**关键问题**：如何到达第 n 阶？

**两种情况**：
1. 从第 `n-1` 阶爬 1 阶到达
2. 从第 `n-2` 阶爬 2 阶到达

**状态转移方程**：
```
dp[n] = dp[n-1] + dp[n-2]
```

**直观理解**：
```
第 n 阶的方法数 = 
  (前一阶的所有方法后面加1步) + 
  (前两阶的所有方法后面加2步)
```

**示例**（n=4）：
```
从 n=3 的方法：
  [1,1,1] → [1,1,1,1]
  [1,2]   → [1,2,1]
  [2,1]   → [2,1,1]

从 n=2 的方法：
  [1,1] → [1,1,2]
  [2]   → [2,2]

总共 3 + 2 = 5 种
```

</details>

---

### 🌟 提示 Level 3：DP 实现
<details>
<summary>点击查看提示3</summary>

**步骤1：定义状态**
```cpp
dp[i] 表示到达第 i 阶的方法数
```

**步骤2：初始化**
```cpp
dp[1] = 1
dp[2] = 2
```

**步骤3：状态转移**
```cpp
for (int i = 3; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2];
}
```

**完整代码**：
```cpp
int climbStairs(int n) {
    if (n <= 2) return n;
    
    vector<int> dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    return dp[n];
}
```

</details>

---

### 🌟 提示 Level 4：空间优化
<details>
<summary>点击查看提示4</summary>

**观察**：计算 `dp[i]` 只需要 `dp[i-1]` 和 `dp[i-2]`

**优化**：用两个变量代替数组

```cpp
int climbStairs(int n) {
    if (n <= 2) return n;
    
    int prev2 = 1;  // dp[i-2]
    int prev1 = 2;  // dp[i-1]
    
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;  // 更新 prev2
        prev1 = curr;   // 更新 prev1
    }
    
    return prev1;
}
```

**空间复杂度**：O(n) → O(1) ✅

</details>

---

## 🔨 动手实践

### 任务1：手动计算
计算 n=6 的所有方法（提示：应该是13种）

### 任务2：实现 DP 数组版本
```cpp
int climbStairs(int n) {
    // TODO: 使用 DP 数组实现
}
```

### 任务3：实现空间优化版本
```cpp
int climbStairs(int n) {
    // TODO: 使用滚动变量实现
}
```

### 任务4：测试
```cpp
n = 1  // 预期: 1
n = 2  // 预期: 2
n = 3  // 预期: 3
n = 5  // 预期: 8
n = 10 // 预期: 89
```

---

## 🎯 动态规划模板

### 标准流程

**1. 定义状态**
- 明确 `dp[i]` 的含义

**2. 找状态转移方程**
- 当前状态如何由之前的状态得到

**3. 初始化**
- 确定边界条件

**4. 遍历顺序**
- 通常从小到大

**5. 返回结果**
- 最终答案是 `dp[?]`

---

## 🚀 进阶挑战

### 挑战1：每次可以爬 1, 2, 3 阶
修改代码支持每次爬 1, 2, 或 3 阶。

**提示**：
```cpp
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
```

### 挑战2：使用最小花费爬楼梯
每个台阶有花费 `cost[i]`，求最小花费。

**提示**：
```cpp
dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
```

### 挑战3：打印所有方法
不仅返回数量，打印所有爬楼梯的方法。

**提示**：使用回溯法。

---

## ✅ 自检清单

- [ ] 我理解了为什么是斐波那契数列
- [ ] 我能推导出状态转移方程
- [ ] 我知道如何定义 DP 状态
- [ ] 我理解了初始化的重要性
- [ ] 我能实现空间优化
- [ ] 我知道动态规划的标准流程

---

## 📌 核心要点

**状态定义**：
```
dp[i] = 到达第 i 阶的方法数
```

**转移方程**：
```
dp[i] = dp[i-1] + dp[i-2]
```

**空间优化**：
```
只保留前两个状态：prev1, prev2
```

**本质**：
```
这是斐波那契数列的应用
```

---

## 🧠 思维提升

### 为什么能用 DP？

满足两个条件：
1. **最优子结构**：大问题的解由小问题的解组成
2. **重叠子问题**：计算过程中会重复计算相同的子问题

### DP vs 递归

```cpp
// 递归（会重复计算）
int climb(int n) {
    if (n <= 2) return n;
    return climb(n-1) + climb(n-2);
}

// DP（记忆化，避免重复）
int climb(int n) {
    dp[i] = dp[i-1] + dp[i-2];
}
```

---

**下一步**：独立实现并对照 `solution.md`！
