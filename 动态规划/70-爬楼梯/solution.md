# 70. 爬楼梯

## 📝 题目描述

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**
```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**约束条件：**
- `1 <= n <= 45`

---

## ⭐ 解法一：动态规划

### 思路

**核心观察**：到达第 `n` 阶的方法数 = 到达第 `n-1` 阶的方法数 + 到达第 `n-2` 阶的方法数

**原因**：
- 如果最后一步爬 1 阶，那么之前在第 `n-1` 阶
- 如果最后一步爬 2 阶，那么之前在第 `n-2` 阶

**状态转移方程**：
```
dp[n] = dp[n-1] + dp[n-2]
```

**初始状态**：
```
dp[1] = 1  (只有一种方法：爬1阶)
dp[2] = 2  (两种方法：1+1 或 2)
```

**这就是斐波那契数列！**

### 代码实现（DP数组）
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;
        
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

---

## 🚀 解法二：空间优化

### 思路
`dp[i]` 只依赖于 `dp[i-1]` 和 `dp[i-2]`，不需要整个数组。

### 代码实现
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;
        
        int prev2 = 1;  // dp[i-2]
        int prev1 = 2;  // dp[i-1]
        
        for (int i = 3; i <= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        
        return prev1;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)

---

## 🎯 核心知识点

### 1. 动态规划五步法

**① 定义状态**：
- `dp[i]`：到达第 i 阶的方法数

**② 状态转移方程**：
```
dp[i] = dp[i-1] + dp[i-2]
```

**③ 初始化**：
```
dp[1] = 1
dp[2] = 2
```

**④ 遍历顺序**：
- 从小到大

**⑤ 返回结果**：
```
dp[n]
```

### 2. 与斐波那契数列的关系

```
n:     1  2  3  4  5  6  7  8
dp[n]: 1  2  3  5  8 13 21 34
斐波那契: 1  1  2  3  5  8 13 21

dp[n] = Fibonacci(n+1)
```

### 3. 状态压缩

从 O(n) 空间优化到 O(1) 空间：
- 观察状态转移方程，当前状态只依赖于前两个状态
- 使用滚动变量代替数组

---

## 🔍 图解过程

以 `n = 5` 为例：

```
n = 1: dp[1] = 1
       方法：[1]

n = 2: dp[2] = 2
       方法：[1,1], [2]

n = 3: dp[3] = dp[2] + dp[1] = 2 + 1 = 3
       方法：[1,1,1], [1,2], [2,1]

n = 4: dp[4] = dp[3] + dp[2] = 3 + 2 = 5
       方法：
       - 从 dp[3] 的3种方法后面加1
       - 从 dp[2] 的2种方法后面加2

n = 5: dp[5] = dp[4] + dp[3] = 5 + 3 = 8
```

---

## 🎓 变式题目

### 变式1：每次可以爬 1, 2, 3 阶
**状态转移方程**：
```
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
```

### 变式2：使用最小花费爬楼梯（LeetCode 746）
每个台阶有花费，求最小花费到达楼顶。

**状态转移方程**：
```
dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
```

### 变式3：每次可以爬任意阶
如果给定一个数组 `steps`，每次可以爬 `steps[i]` 阶，求方法数。

---

## 📌 记忆要点

- **模式**：计数问题 → 动态规划
- **本质**：斐波那契数列
- **状态定义**：到达第 i 阶的方法数
- **转移方程**：`dp[i] = dp[i-1] + dp[i-2]`
- **优化**：滚动变量，O(1) 空间

---

## 🔨 常见错误

### 错误1：初始化错误
```cpp
// ❌ 错误
dp[0] = 1;
dp[1] = 1;

// ✅ 正确
dp[1] = 1;
dp[2] = 2;
```

### 错误2：边界处理
```cpp
// ❌ 可能越界
if (n == 1) return 1;
vector<int> dp(n + 1);

// ✅ 更安全
if (n <= 2) return n;
```

---

## 💡 扩展：矩阵快速幂

对于大规模问题（n 很大），可以使用矩阵快速幂优化到 O(log n)。

**矩阵形式**：
```
[F(n)  ]   [1 1]^(n-1)   [1]
[F(n-1)]   [1 0]         [0]
```

---

**标签**：`动态规划` `数学` `easy`
