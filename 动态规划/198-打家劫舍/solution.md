# 198. 打家劫舍

## 📝 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下**，一夜之内能够偷窃到的最高金额。

**示例 1：**
```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**
```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**约束条件：**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

---

## ⭐ 解法一：动态规划（DP数组）

### 思路

**状态定义**：
- `dp[i]`：偷到第 i 个房屋时能获得的最大金额

**状态转移方程**：
对于第 i 个房屋，有两个选择：
1. **偷第 i 个**：`dp[i-2] + nums[i]`（不能偷 i-1，所以加上 i-2 的最大值）
2. **不偷第 i 个**：`dp[i-1]`（保持 i-1 的最大值）

```
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

**初始化**：
```
dp[0] = nums[0]
dp[1] = max(nums[0], nums[1])
```

### 代码实现
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        
        vector<int> dp(n);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        
        for (int i = 2; i < n; i++) {
            dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
        }
        
        return dp[n-1];
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

---

## 🚀 解法二：空间优化

### 思路

`dp[i]` 只依赖于 `dp[i-1]` 和 `dp[i-2]`，用两个变量代替数组。

### 代码实现
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        
        int prev2 = nums[0];                    // dp[i-2]
        int prev1 = max(nums[0], nums[1]);      // dp[i-1]
        
        for (int i = 2; i < n; i++) {
            int curr = max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = curr;
        }
        
        return prev1;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)

---

## 🎯 核心知识点

### 1. 动态规划五步法

**① 定义状态**：
- `dp[i]`：偷到第 i 个房屋时的最大金额

**② 状态转移方程**：
```
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
       = max(不偷i, 偷i)
```

**③ 初始化**：
```
dp[0] = nums[0]
dp[1] = max(nums[0], nums[1])
```

**④ 遍历顺序**：
- 从左到右

**⑤ 返回结果**：
```
dp[n-1]
```

### 2. 决策过程

对于每个房屋，有两个选择：

```
偷第 i 个房屋：
  - 不能偷第 i-1 个
  - 最大金额 = dp[i-2] + nums[i]

不偷第 i 个房屋：
  - 保持之前的最大金额
  - 最大金额 = dp[i-1]

取两者中的较大值
```

---

## 🔍 图解过程

以 `nums = [2, 7, 9, 3, 1]` 为例：

```
i=0: dp[0] = 2
     偷0号房

i=1: dp[1] = max(2, 7) = 7
     偷1号房（不偷0）

i=2: dp[2] = max(dp[1], dp[0] + 9)
           = max(7, 2 + 9)
           = 11
     偷0和2号房

i=3: dp[3] = max(dp[2], dp[1] + 3)
           = max(11, 7 + 3)
           = 11
     保持偷0和2号房

i=4: dp[4] = max(dp[3], dp[2] + 1)
           = max(11, 11 + 1)
           = 12
     偷0、2、4号房

最大金额：12
```

**决策路径**：偷 [0, 2, 4] → 2 + 9 + 1 = 12

---

## 🎓 变式题目

### 1. 打家劫舍 II（LeetCode 213）
房屋围成一圈，第一间和最后一间相邻。

**思路**：
- 情况1：偷第一间，不偷最后一间
- 情况2：不偷第一间，偷最后一间
- 分别计算，取最大值

### 2. 打家劫舍 III（LeetCode 337）
房屋排列成二叉树形状。

**思路**：树形 DP，递归处理左右子树。

### 3. 删除并获得点数（LeetCode 740）
类似打家劫舍，选择一个数字后，相邻数字不能选。

---

## 📌 记忆要点

- **状态定义**：`dp[i]` = 偷到第 i 个房屋的最大金额
- **转移方程**：`max(不偷i, 偷i)`
- **关键**：相邻房屋不能同时偷
- **优化**：滚动变量，O(1) 空间

---

## 🔨 常见错误

### 错误1：初始化错误
```cpp
// ❌ 错误
dp[0] = 0;
dp[1] = nums[0];

// ✅ 正确
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);
```

### 错误2：理解转移方程
```cpp
// ❌ 错误：以为必须偷 i
dp[i] = dp[i-2] + nums[i];

// ✅ 正确：可以选择不偷
dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
```

---

**标签**：`数组` `动态规划` `medium`
