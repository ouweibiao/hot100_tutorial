# 152. 乘积最大子数组

## 题目描述

给你一个整数数组 `nums`，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**
```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**
```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组（中间隔了个 0）。
```

## 解题思路

### 方法：动态规划
- 与 [53. 最大子数组和](../../数组/53-最大子数组和/guide.md) 类似，但这里是**乘法**。
- **难点**：负负得正。一个最小的负数乘以另一个负数可能会变成最大的正数。
- **状态定义**：
  - `maxDP[i]`：以 `i` 结尾的子数组的最大乘积。
  - `minDP[i]`：以 `i` 结尾的子数组的最小乘积（为了处理负数）。
- **状态转移**：
  - 遍历到 `nums[i]` 时，可能的三种情况：
    1. `nums[i]` 自己作为一个子数组（比如前面是 0）。
    2. `nums[i]` 是正数，乘以 `maxDP[i-1]` 得到更大值。
    3. `nums[i]` 是负数，乘以 `minDP[i-1]`（原本最小的负数）变成最大的正数。
  - 转移方程：
    - `maxDP[i] = max(nums[i], max(maxDP[i-1] * nums[i], minDP[i-1] * nums[i]))`
    - `minDP[i] = min(nums[i], min(maxDP[i-1] * nums[i], minDP[i-1] * nums[i]))`
- **空间优化**：
  - 只需要前一个状态，可以用两个变量滚动更新，空间复杂度 O(1)。

## 易错点
- 必须维护 `minDP`，否则无法处理负负得正的情况。
- 更新 `maxDP` 时，原来的 `maxDP` 会改变，计算 `minDP` 时要用**旧的** `maxDP`，所以需要临时变量存储。
