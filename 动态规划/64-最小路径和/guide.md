# 64. 最小路径和

## 题目描述

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明**：每次只能向下或者向右移动一步。

**示例 1:**
```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

## 解题思路

### 方法：动态规划
- **状态定义**：`dp[i][j]` 表示到达 `(i, j)` 的最小路径和。
- **状态转移**：
  - `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`。
  - 即：从上方或左方选一个较小的路径和，加上当前格子的值。
- **边界处理**：
  - `(0, 0)`：`dp[0][0] = grid[0][0]`。
  - 第一行：只能从左边来，累加。
  - 第一列：只能从上边来，累加。
- **空间优化**：
  - 可以直接在原数组 `grid` 上修改，不使用额外空间。

## 复杂度
- 时间复杂度：O(M * N)。
- 空间复杂度：O(1) (原地修改) 或 O(M * N)。
