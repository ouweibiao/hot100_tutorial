# 200. 岛屿数量

## 题目描述

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

**示例 1：**
```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

---

## 解法：DFS / BFS

### 核心思路
遍历网格，每遇到一个 `'1'`，计数加一，并启动一次搜索（DFS 或 BFS），将与该 `'1'` 相连的所有 `'1'` 都标记为 `'0'`（表示已访问）。
这样，下次遍历到这些位置时，就会因为它们已经是 `'0'` 而跳过，从而保证每个岛屿只被计数一次。

这种策略形象地称为**“沉岛思想”**：发现一个岛，就把它沉下去（变成水），以免重复发现。

### 图解
1. 遍历到 `(0,0)` 是 '1' -> 发现新岛屿，Count=1。
2. 启动 DFS，把 `(0,0)` 及其相连的陆地全部置为 '0'。
3. 继续遍历，遇到的都是 '0'（包括刚才沉下去的）。
4. 如果再遇到 '1'，说明是另一个独立的岛屿，Count++，重复上述过程。

### 复杂度
- 时间复杂度：O(MN)，每个点最多被访问两次（一次遍历，一次DFS）。
- 空间复杂度：DFS需要栈空间 O(MN)，BFS需要队列空间 O(min(M,N))。
