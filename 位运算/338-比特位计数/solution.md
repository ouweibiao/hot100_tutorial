# 338. 比特位计数

## 题目描述

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**
```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

---

## 解法：动态规划 / Brian Kernighan 算法

### 解法一：Brian Kernighan 算法（最直观）
对于每个数 `i`，我们可以不断执行 `i = i & (i - 1)` 来消除最低位的 1，直到 `i` 变为 0。消除的次数就是 1 的个数。
时间复杂度：O(N * log N)（因为每个数有 log N 位）。

### 解法二：动态规划（最高效）
我们要计算 `i` 的二进制中 1 的个数。
- **奇数**：`i` 的二进制比 `i-1` 多最后一位的 1。所以 `count[i] = count[i-1] + 1`。
- **偶数**：`i` 的二进制和 `i/2` 相比，只是末尾多了一个 0，1 的个数不变。所以 `count[i] = count[i/2]`。
- 或者统一来看：`i` 的 1 的个数等于 `i >> 1` （去掉最后一位）的 1 的个数，加上 `i` 的最后一位（`i & 1`）。
  即：`count[i] = count[i >> 1] + (i & 1)`。

### 代码实现（动态规划）

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> dp(n + 1);
        dp[0] = 0;
        
        for (int i = 1; i <= n; ++i) {
            // dp[i] = dp[i >> 1] + (i & 1);
            // i >> 1 肯定比 i 小，所以 dp[i >> 1] 已经计算过了
            dp[i] = dp[i >> 1] + (i & 1);
        }
        
        return dp;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(N)。每个数只需要 O(1) 的时间计算。
- **空间复杂度**：O(1)。除了返回数组外，不需要额外空间。

### 易错点
- 数组大小是 `n + 1`。
- 位运算优先级：`+` 优先级高于 `&`，所以 `i & 1` 最好加括号，虽然这里顺序没问题，但习惯要好。

---

## 总结
- 利用位运算性质进行 DP 的好题。
- `i & (i - 1)` 是消除最低位 1 的技巧。
- `i >> 1` 是去掉最低位的技巧。
