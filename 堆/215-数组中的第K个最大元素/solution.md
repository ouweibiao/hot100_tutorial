# 215. 数组中的第K个最大元素

## 题目描述

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。
请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

**示例 1:**
```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**
```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

---

## 解法：堆（优先队列） / 快速选择

### 解法一：最小堆（优先队列）
维护一个大小为 `k` 的**小顶堆**。
遍历数组：
1. 将当前元素加入堆中。
2. 如果堆的大小超过 `k`，则弹出堆顶元素（最小值）。
这样，遍历结束后，堆中剩下的 `k` 个元素就是最大的 `k` 个元素，而堆顶就是这 `k` 个元素中最小的那个，即**第 k 大的元素**。

### 解法二：快速选择（Quick Select）
类似于快速排序的分区思想。
1. 随机选择一个基准值 `pivot`。
2. 将数组分为两部分：小于 `pivot` 的和大于 `pivot` 的。
3. 判断 `pivot` 的最终位置 `p`：
   - 如果 `p == n - k`，说明找到了第 `k` 大的元素。
   - 如果 `p < n - k`，说明目标在右半部分，递归右边。
   - 如果 `p > n - k`，说明目标在左半部分，递归左边。

### 代码实现（基于最小堆）

```cpp
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // 创建一个小顶堆
        priority_queue<int, vector<int>, greater<int>> minHeap;
        
        for (int num : nums) {
            minHeap.push(num);
            // 如果堆的大小超过 k，弹出堆顶（当前的最小值）
            if (minHeap.size() > k) {
                minHeap.pop();
            }
        }
        
        // 堆顶就是第 k 大的元素
        return minHeap.top();
    }
};
```

### 复杂度分析
- **时间复杂度**：O(N log K)。
- **空间复杂度**：O(K)，堆的大小。

### 易错点
- 找第 `k` 大，用**小顶堆**（保留最大的 `k` 个）。
- 找第 `k` 小，用**大顶堆**（保留最小的 `k` 个）。

---

## 总结
- 这是一个经典的 Top K 问题。
- 堆解法适合处理数据流或 `k` 较小的情况。
- 快速选择算法的平均时间复杂度是 O(N)，优于堆解法，但最坏情况是 O(N^2)（虽然可以通过随机化避免）。在面试中，堆解法通常更容易写且不易出错。
