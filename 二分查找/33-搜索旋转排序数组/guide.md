# 33. 搜索旋转排序数组

## 题目描述

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

## 解题思路

### 方法：二分查找
- **核心思想**：
  - 旋转排序数组的特点是：**将数组一分为二，其中一定有一个是有序的**。
  - 我们可以先判断哪一部分有序，然后看目标值是否在有序的那一部分里。
- **流程**：
  - `mid = left + (right - left) / 2`。
  - 如果 `nums[mid] == target`，返回 `mid`。
  - 判断哪边有序：
    - 如果 `nums[0] <= nums[mid]`，说明左半边 `[0, mid]` 有序。
      - 如果 `nums[0] <= target < nums[mid]`，说明 target 在左半边，`right = mid - 1`。
      - 否则 target 在右半边，`left = mid + 1`。
    - 否则，右半边 `[mid, n-1]` 有序。
      - 如果 `nums[mid] < target <= nums[n-1]`，说明 target 在右半边，`left = mid + 1`。
      - 否则 target 在左半边，`right = mid - 1`。

## 复杂度
- 时间复杂度：O(log N)。
- 空间复杂度：O(1)。
