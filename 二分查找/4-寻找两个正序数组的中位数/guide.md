# 4. 寻找两个正序数组的中位数

## 题目描述

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**
```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

## 解题思路

### 方法：二分查找 (划分数组)
- **核心思想**：
  - 中位数的作用是将一个集合划分成两个长度相等的子集，其中一个子集的元素总是大于另一个子集。
  - 我们要在 `nums1` 和 `nums2` 中分别找到分割点 `i` 和 `j`，使得：
    1. `len(left_part) == len(right_part)` (或相差 1)。
    2. `max(left_part) <= min(right_part)`。
  - 由于 `j` 可以通过 `i` 计算出来（`i + j = (m + n + 1) / 2`），我们只需要对 `i` 进行二分查找。
- **流程**：
  - 保证 `nums1` 是较短的数组（如果不是，交换）。
  - 在 `nums1` 的区间 `[0, m]` 上进行二分查找 `i`。
  - 计算 `j = (m + n + 1) / 2 - i`。
  - 检查是否满足交叉条件：
    - `nums1[i-1] <= nums2[j]`
    - `nums2[j-1] <= nums1[i]`
  - 处理边界情况（`i=0`, `i=m`, `j=0`, `j=n`）。
  - 找到合适的 `i` 后，计算中位数：
    - 左边最大值 `maxLeft = max(nums1[i-1], nums2[j-1])`。
    - 如果总长度是奇数，中位数就是 `maxLeft`。
    - 如果总长度是偶数，右边最小值 `minRight = min(nums1[i], nums2[j])`，中位数是 `(maxLeft + minRight) / 2.0`。

## 复杂度
- 时间复杂度：O(log(min(M, N)))。
- 空间复杂度：O(1)。
