# 153. 寻找旋转排序数组中的最小值

## 题目描述

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

## 解题思路

### 方法：二分查找
- **核心思想**：
  - 最小值是唯一一个满足 `nums[i] < nums[i-1]` 的元素（如果存在旋转）。
  - 或者我们可以比较 `nums[mid]` 和 `nums[right]`。
- **流程**：
  - `left = 0`, `right = n - 1`。
  - 循环条件 `left < right`（注意不是 `<=`，因为我们要找确定的一个位置）。
  - `mid = left + (right - left) / 2`。
  - 如果 `nums[mid] < nums[right]`：说明 `[mid, right]` 这一段是有序的，最小值肯定在 `mid` 或者 `mid` 左边。`right = mid`。
  - 如果 `nums[mid] > nums[right]`：说明最小值在 `mid` 右边。`left = mid + 1`。
  - 循环结束时 `left == right`，返回 `nums[left]`。

## 复杂度
- 时间复杂度：O(log N)。
- 空间复杂度：O(1)。
