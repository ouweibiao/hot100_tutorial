# 114. 二叉树展开为链表

## 题目描述

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：
- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 **前序遍历** 顺序相同。

## 解题思路

### 方法一：前序遍历 + 额外空间
- 将前序遍历的结果存入数组，然后重新连接。
- 空间复杂度 O(N)。

### 方法二：原地修改 (寻找前驱节点)
- **观察**：对于当前节点 `curr`，如果它有左子树，那么它的右子树应该接到 **左子树的最右节点** 后面。
- **算法**：
  1. `curr = root`。
  2. 如果 `curr->left` 不为空：
     - 找到 `curr->left` 的最右节点 `predecessor`（即左子树中序遍历的最后一个节点，也是前序遍历中 `curr` 左子树的最后一个节点）。
     - 将 `curr` 的右子树接到 `predecessor->right` 上。
     - 将 `curr->left` 移到 `curr->right`。
     - `curr->left` 置空。
  3. `curr = curr->right`，重复步骤 2。
- **复杂度**：时间 O(N)，空间 O(1)。

### 方法三：后序遍历变种 (右-左-根)
- 如果我们反向进行前序遍历（即先右后左再根），可以用一个全局变量 `prev` 记录上一个访问的节点。
- `root->right = prev`
- `root->left = null`
- `prev = root`
- 这种方法递归实现简单，但空间复杂度 O(H)。

## 推荐
原地修改方法（寻找前驱）最符合题目"原地"的要求，且空间复杂度最优。
