# 297. 二叉树的序列化与反序列化

## 题目描述

序列化是将一个数据结构或者对象转换为连续的比特位的过程，进而可以将转换后的数据存储在文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

## 解题思路

### 方法：BFS (层序遍历)
- **序列化**：
  - 使用队列进行层序遍历。
  - 遇到 `null` 节点也需要记录（例如记录为 "None" 或 "#"），以保持结构信息。
  - 使用逗号分隔每个节点的值。
  - 示例：`[1,2,3,null,null,4,5]` -> `"1,2,3,None,None,4,5,None,None,None,None,"`
- **反序列化**：
  - 将字符串按逗号分割成列表。
  - 使用队列重建树。
  - 根节点入队。
  - 每次从队列取出一个节点，然后从列表中取两个值分别作为左、右子节点（如果不是 "None"），并将新节点入队。

### 方法：DFS (前序遍历)
- **序列化**：
  - 递归遍历：`root -> left -> right`。
  - 如果节点为空，加入 "None"。
- **反序列化**：
  - 使用一个指针（或迭代器）指向当前的列表位置。
  - 递归构建：
    - 如果当前值是 "None"，返回 `null`，指针后移。
    - 否则创建新节点，指针后移。
    - `root->left = deserialize()`
    - `root->right = deserialize()`

## 复杂度
- 时间复杂度：O(N)。
- 空间复杂度：O(N)。
