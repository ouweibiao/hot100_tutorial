# 98. 验证二叉搜索树

## 题目描述

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效 二叉搜索树定义如下：**
- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

## 解题思路

### 方法一：递归 (带上下界)
- **误区**：只判断 `root->val > root->left->val` 和 `root->val < root->right->val` 是不够的。
  - 例如 `[5,4,6,null,null,3,7]`，3 在 6 的左边，但 3 < 5，不满足 BST 性质（右子树所有节点都必须大于根节点）。
- **正确做法**：
  - 递归时传递当前节点允许的取值范围 `(min, max)`。
  - 根节点范围 `(-inf, +inf)`。
  - 左子节点范围 `(min, root->val)`。
  - 右子节点范围 `(root->val, max)`。
  - 遇到空节点返回 true。
  - 如果节点值不在范围内，返回 false。

### 方法二：中序遍历 (Inorder Traversal)
- **核心性质**：二叉搜索树的中序遍历结果一定是 **严格单调递增** 的。
- **做法**：
  - 进行中序遍历。
  - 记录前一个访问的节点值 `pre`。
  - 如果 `root->val <= pre`，说明不是 BST，返回 false。
  - 更新 `pre = root->val`。

## 推荐
中序遍历法逻辑简单，不需要处理 `LONG_MIN` / `LONG_MAX` 的边界问题（只需要记录前一个值）。
